#include <stdio.h>
#include <time.h>
#include <stdlib.h>
#include <hip/hip_runtime.h>
#include <hip/hip_runtime_api.h>

typedef struct{
        int width;
        int height;
        float* elements;
}Matrix;

#define BLOCK_SIZE 16

__global__ void MatMulKernel(const Matrix,const Matrix,Matrix);

void initial(float* A,int N)
{
     int i;
     for(i = 0;i<N;i++)
     {
        A[i] = rand()%10;
     }
}

void shuchu(Matrix A,int N)
{

    int j=0;
    for(int i=0; i < N; i++)
    {
        if( j == A.width)
        {
                printf("\n");
                j = 0;
                i--;
        }else
        {
              printf("%15lf",A.elements[i]);
                j++;
        }
    }
}

__global__ void MatMulKernel(Matrix A,Matrix B,Matrix C)
{
        float Cvalue = 0;
        int row = hipBlockIdx_y * hipBlockDim_y + hipThreadIdx_y;
        int col = hipBlockIdx_x * hipBlockDim_x + hipThreadIdx_x;
        for(int e = 0; e < A.width; ++e)
        {
                Cvalue += A.elements[row * A.width + e] * B.elements[e*B.width + col];
        }
        C.elements[row * C.width + col] = Cvalue;
}


void MatMul(Matrix A,Matrix B,Matrix C)
{
        Matrix d_A;
        Matrix d_B;
        Matrix d_C;
        d_A.width = A.width;
        d_A.height = A.height;
        d_B.width = B.width;
        d_B.height = B.height;
        d_C.width = C.width;
        d_C.height = C.height;
        size_t size_A = A.width * A.height * sizeof(float);
        size_t  size_B = B.width * B.height * sizeof(float);
        size_t  size_C = C.width * C.height * sizeof(float);

        hipMalloc(&d_A.elements,size_A);
        hipMalloc(&d_B.elements,size_B);
        hipMalloc(&d_C.elements,size_C);
        dim3 dimBlock(BLOCK_SIZE,BLOCK_SIZE);
        dim3 dimGrid(B.width / dimBlock.x,A.height / dimBlock.y);

        hipMemcpy(d_A.elements,A.elements,size_A,hipMemcpyHostToDevice);
        hipMemcpy(d_B.elements,B.elements,size_B,hipMemcpyHostToDevice);
        //测试时间
        float gpu_time;
        hipEvent_t start_GPU,stop_GPU;
        hipEventCreate(&start_GPU);
        hipEventCreate(&stop_GPU);
        hipEventRecord(start_GPU,0);

        hipLaunchKernelGGL(MatMulKernel,dimGrid,dimBlock,0,0,d_A,d_B,d_C);

        hipEventRecord(stop_GPU,0);
        hipEventSynchronize(start_GPU);
        hipEventSynchronize(stop_GPU);
        hipEventElapsedTime(&gpu_time,start_GPU,stop_GPU);
        hipDeviceSynchronize();
        printf("\nGPU spend time is: %lf(ms)\n",gpu_tim);//时间输出
        hipEventDestroy(start_GPU);
        hipEventDestroy(stop_GPU);
        hipMemcpy(C.elements,d_C.elements,size_C,hipMemcpyDeviceToHost);

        /*大矩阵输出很慢
		printf("\nGPU result is :\n");
        shuchu(C,C.width*C.height);
        printf("\n");*/
        hipFree(d_A.elements);
        hipFree(d_B.elements);
        hipFree(d_C.elements);
}
int main()
{
        Matrix A;
        Matrix B;
        Matrix C;
        A.width = 5730;
        A.height = 5730;
        B.width = 5730;
        B.height = 5730;
        C.width = 5730;
        C.height = 5730;

        int size = 5730 * 5730;
        int size_A = A.width * A.height * sizeof(float);
        int size_B = B.width * B.height * sizeof(float);
        int size_C = C.width * C.height * sizeof(float);

        A.elements = (float *)malloc(size_A);
        B.elements = (float *)malloc(size_B);
        C.elements = (float *)malloc(size_C);

        initial(A.elements,A.height*A.width);
        printf("A:\n");
        //shuchu(A,A.width*A.height);

        printf("\nB:\n");
        initial(B.elements,B.height*B.width);
        //shuchu(B,B.width*B.height);


        printf("\n");
        MatMul(A,B,C);
        return 0;
}
